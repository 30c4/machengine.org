<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GPU overview on Mach: zig game engine &amp; graphics toolkit</title><link>https://machengine.org/v0.2/engine/gpu/</link><description>Recent content in GPU overview on Mach: zig game engine &amp; graphics toolkit</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://machengine.org/v0.2/engine/gpu/index.xml" rel="self" type="application/rss+xml"/><item><title>GPU error handling</title><link>https://machengine.org/v0.2/engine/gpu/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://machengine.org/v0.2/engine/gpu/errors/</guid><description>GPU error handling Asynchronous nature GPUs have largely asynchronous APIs: you build up a command buffer which encodes a number of commands instructing the GPU to do something, and then you ask the GPU to execute that buffer of commands. As a result, errors must be handled asynchronously as well. try isn&amp;rsquo;t going to work here.
Error scopes WebGPU has a concept of error scopes, you can push an error scope onto the stack and pop an error scope.</description></item><item><title>GPU memory management</title><link>https://machengine.org/v0.2/engine/gpu/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://machengine.org/v0.2/engine/gpu/memory/</guid><description>GPU memory management Reference counting GPU objects like gpu.Texture, gpu.Buffer, or any other object which has a .reference, .release and .destroy method - use reference counting.
Although we love explicit memory management, GPU memory is perhaps one of the best use-cases for reference counting. All WebGPU objects are reference counted, and it&amp;rsquo;s not just because it originated as a browser API.
Guidance Use .reference() and .release() to release memory of objects.</description></item></channel></rss>