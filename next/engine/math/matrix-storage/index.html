<!doctype html><html><head><link rel=stylesheet href=https://machengine.org/next/layouts/default.5a2984849ab54d0815db4053f7577d95f908a85a1cefad99848234ec223ced0c.css><link rel=icon type=image/x-icon href=https://machengine.org/next/favicon.ico><link rel=stylesheet href=https://machengine.org/next/assets/font/stylesheet.css><link rel=stylesheet href=https://machengine.org/next/assets/font/inter/inter.css><script async defer data-domain=hexops.com src=https://machengine.org/next/opendata.js></script><meta charset=utf-8><title>Matrix storage - Mach engine | Mach engine - game engine & graphics toolkit for the future</title><link rel=canonical href=https://machengine.org/next/engine/math/matrix-storage/><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noindex"><meta property="og:title" content="Matrix storage - Mach engine"><meta property="og:description" content="Matrix storage Matrices in Mach use:
 Column-major matrix storage Column-vectors (i.e. right-associative multiplication, matrix * vector = vector)  The benefit of using this &ldquo;OpenGL-style&rdquo; matrix is that it matches the conventions accepted by the scientific community, it&rsquo;s what you&rsquo;ll find in linear algebra textbooks. It also matches WebGPU, Vulkan, Unity3D, etc. It does NOT match DirectX-style which e.g. Unreal Engine uses.
Note: many people will say &ldquo;row major&rdquo; or &ldquo;column major&rdquo; and implicitly mean three or more different concepts; to avoid confusion we&rsquo;ll go over this in more depth below."><meta property="og:type" content="article"><meta property="og:url" content="https://machengine.org/next/engine/math/matrix-storage/"><meta property="article:section" content="engine"><meta name=twitter:card content="summary"><meta name=twitter:title content="Matrix storage - Mach engine"><meta name=twitter:description content="Matrix storage Matrices in Mach use:
 Column-major matrix storage Column-vectors (i.e. right-associative multiplication, matrix * vector = vector)  The benefit of using this &ldquo;OpenGL-style&rdquo; matrix is that it matches the conventions accepted by the scientific community, it&rsquo;s what you&rsquo;ll find in linear algebra textbooks. It also matches WebGPU, Vulkan, Unity3D, etc. It does NOT match DirectX-style which e.g. Unreal Engine uses.
Note: many people will say &ldquo;row major&rdquo; or &ldquo;column major&rdquo; and implicitly mean three or more different concepts; to avoid confusion we&rsquo;ll go over this in more depth below."></head><body><div class=navbar><div class=content><a href=https://machengine.org/next/ class=logo><div class=img></div></a><div><a href=https://machengine.org/next/about class="item glass-link">about</a>
<a href=https://github.com/sponsors/slimsag class="item glass-link">donate</a>
<a href=https://devlog.hexops.com/categories/mach/ class="item glass-link">devlog</a>
<a href=https://github.com/hexops/mach class="svg-item glass-link"><img alt=GitHub class=svg-icon src=https://machengine.org/next/img/github.svg></a>
<a href=https://discord.gg/XNG3NZgCqp class="svg-item glass-link"><img alt=Discord class=svg-icon src=https://machengine.org/next/img/discord.svg></a></div></div></div><div class="alert warning"><span><strong>HEY YOU!</strong> We're still working on this site, please don't share it in very public places :)</span></div><div id=content><link rel=stylesheet href=https://machengine.org/next/layouts/docs.04e3792847046e165154a56a0c74cf6d9da9f84f6366d0d6e94cd8e19e191197.css><main aria-role=main class=main-docs><aside><ul><li><a href=https://machengine.org/next/engine><span>Engine overview</span></a></li><li><a href=https://machengine.org/next/about/known-issues><span>Known issues â®•</span></a></li><li><h3><span>Math</span></h3></li><ul class=sub-menu><li><a href=https://machengine.org/next/engine/math>Overview</a></li><li><a href=https://machengine.org/next/engine/math/coordinate-system>Coordinate system</a></li><li><a href=https://machengine.org/next/engine/math/matrix-storage>Matrix storage</a></li></ul></ul></aside><div class=docs><h1 id=matrix-storage>Matrix storage</h1><p>Matrices in Mach use:</p><ul><li>Column-major matrix storage</li><li>Column-vectors (i.e. right-associative multiplication, matrix * vector = vector)</li></ul><p>The benefit of using this &ldquo;OpenGL-style&rdquo; matrix is that it matches the conventions accepted by the scientific community, it&rsquo;s what you&rsquo;ll find in linear algebra textbooks. It also matches WebGPU, Vulkan, Unity3D, etc. It does NOT match DirectX-style which e.g. Unreal Engine uses.</p><p><strong>Note:</strong> many people will say &ldquo;row major&rdquo; or &ldquo;column major&rdquo; and implicitly mean three or more different concepts; to avoid confusion we&rsquo;ll go over this in more depth below.</p><h2 id=mathematical-matrix-order-row-major-column-vectors>Mathematical matrix order: row-major, column-vectors</h2><p>Mathematically, a matrix is defined as <code>m x n</code>, where <code>m</code> is the number of rows (horizontals) and <code>n</code> is the number of columns (verticals.) For example, this 4x4 matrix where <code>a10</code> (zero-indexed) represents the element at the second row and first column of the matrix:</p><pre><code>|a00 a01 a02 a03|
|a10 a11 a12 a13|
|a20 a21 a22 a23|
|a30 a31 a32 a33|
</code></pre><p>Take note of how the mathematical definition and convention used here is <em>rows x columns</em>, an arbitrary choice the science community made to agree rows come first, partly influenced by the fact that English is row-major (read left-to-right, top-to-bottom). This is just a convention and has NOTHING to do with a matrix is stored on a computer. This decision was made because it is nicer to write e.g. matrix translation*vector multiplication on paper like this:</p><pre><code>|1 0 0 tx| |x|   |x+w*tx|
|0 1 0 ty| |y| = |y+w*ty|
|0 0 1 tz| |z|   |z+w*tz|
|0 0 0 tw| |1|   |tw    |
</code></pre><p>Instead of like this:</p><pre><code>          |1  0  0  0 |
|x y z 1| |0  1  0  0 | = |x+w*tx, y+w*ty, z+w*tz, tw|
          |0  0  1  0 |
          |tx ty tz tw|
</code></pre><p>Both of these equations are equal and produce the same result, they&rsquo;re just written differently, mathematicians and the rest of the science community agreed the first one is right and moved on.</p><p>Take special note of how in the first example, the vector <code>[tx, ty, tz, tw]</code> is stored in the fourth <em>column</em> of the matrix, suggesting we have <em>column vectors</em>. In the second example, the same vector is stored in the fourth <em>row</em> of the matrix, suggesting we have <em>row vectors</em>.</p><p>It is also worth noting that as a result of using <em>column vectors</em>, we have right-associative multiplication (the matrix goes on the left, vector on the right; matrix * vector), whereas with <em>row vectors</em> we use left-associative multiplication (the matrix goes on the right, vector on the left; vector * matrix.)</p><p>You should now have the following ground-truths:</p><ol><li>+The mathematical convention is to write matrices in row-major order, using column-vectors.</li></ol><h2 id=programming-languages-are-x-order>&ldquo;Programming languages are X order&rdquo;</h2><p>Programming languages are sometimes said to be in a row-major order or column-major order. Most programming languages, like C, C++, Zig, Rust, etc. are considered to be row-major, because if we give you e.g. this translation matrix, written in the standard mathematical convention where <code>[tx, ty, tz, tw]</code> is a <em>column-vector</em>:</p><pre><code>|1 0 0 tx|
|0 1 0 ty|
|0 0 1 tz|
|0 0 0 tw|
</code></pre><p>And we ask you write it in code as a 2D array with the same visual layout:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=color:#66d9ef>const</span> m <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>f32</span>{
    .{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, tx},
    .{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, ty},
    .{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, tz},
    .{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, tw},
};
</code></pre></div><p>And then ask you to extract the <code>[tx, ty, tz, tw]</code> vector, you will find that you need to index into all four <em>rows of the matrix</em>, the elements of that vector are stored at memory offsets 3, 7, 11, and 15 - not contiguously in memory. In contrast, if we were to write our matrix in code as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=color:#66d9ef>const</span> m <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>f32</span>{
    .{ <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>},
    .{ <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>},
    .{ <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>},
    .{tx, ty, tz, tw},
};
</code></pre></div><p>Then we will find that our <code>[tx, ty, tz, tw]</code> vector is conveniently in contiguous memory at offsets 12, 13, 14, and 15. <code>m[3]</code> <em>is</em> the vector we wanted to extract!</p><p>You should now have the following ground-truths:</p><ol><li>The mathematical convention is to write matrices in row-major order, using column-vectors.</li><li>+Many programming languages are said to be in row-major order, because a 2D array written in
code matching the mathematical convention results in rows, not columns, being stored in
contiguous memory.</li></ol><h2 id=the-two-devils-of-graphics-programming>The two devils of graphics programming</h2><p>Unlike the science community, graphics programmers never agreed universally on whether to use row-vectors or column-vectors, or whether to use row-major or column-major storage. Although there are two independent options you should be aware of (vector type and storage type), in practice there are usually only two styles used:</p><ul><li>DirectX-style: row-major storage, using row-vectors<ul><li>Descendants like Unreal Engine, HLSL, Cg, etc. use this style.</li><li>The <code>[tx, ty, tz, tw]</code> vector is stored in memory offsets 12, 13, 14, and 15.</li></ul></li><li>OpenGL-style:<ul><li>column-major storage, using column-vectors</li><li>Descendants like Unity, GLSL, WebGPU, Vulkan, Metal, WebGL, etc. use this style</li><li>The <code>[tx, ty, tz, tw]</code> vector is stored in memory offsets 12, 13, 14, and 15.</li></ul></li></ul><p>If you&rsquo;re paying close attention, you&rsquo;ll notice that we said the <code>[tx, ty, tz, tw]</code> vector is stored in the same offset in-memory. How can this be? The answer lies in the <em>mathematical convention</em> that each have chosen. OpenGL-style chooses the standard mathematical convention:</p><pre><code>|1 0 0 tx| |x|   |x+w*tx|
|0 1 0 ty| |y| = |y+w*ty|
|0 0 1 tz| |z|   |z+w*tz|
|0 0 0 tw| |1|   |tw    |
</code></pre><p>While DirectX-style chooses a different convention which the science community would disagree with if they had a voice in the matter:</p><pre><code>          |1  0  0  0 |
|x y z 1| |0  1  0  0 | = |x+w*tx, y+w*ty, z+w*tz, tw|
          |0  0  1  0 |
          |tx ty tz tw|
</code></pre><p>When you store the OpenGL-style in column-major storage, the <code>[tx, ty, tz, tw]</code> vector ends up at memory offsets 12, 13, 14, and 15 in contiguous memory.</p><p>When you store the DirectX-style in row-major storage, the <code>[tx, ty, tz, tw]</code> vector <em>also</em> ends up at memory offsets 12, 13, 14, and 15 in contiguous memory.</p><p>What is affected, however, is the multiplication order: with OpenGL-style, you use matrix<em>vector as is standard in the scientific community; while with DirectX-style you use vector</em>matrix.</p><h2 id=endless-confusion>Endless confusion</h2><p>It&rsquo;s very easy to get yourself mixed up. It&rsquo;s also possible to diverge from the OpenGL/DirectX styles, for example by using column-major storage with row-vectors. Because of the fact that transposing from one to the other is trivial, it&rsquo;s also very possible to end up using two different conventions at the same time. This is an endless source of confusion in the computer graphics community, and there is a lot of incorrect information about the topic online.</p><p>Two good sources of information are:</p><ol><li><a href=https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/>https://fgiesen.wordpress.com/2012/02/12/row-major-vs-column-major-row-vectors-vs-column-vectors/</a></li><li><a href=https://en.wikipedia.org/wiki/Row-_and_column-major_order>https://en.wikipedia.org/wiki/Row-_and_column-major_order</a></li></ol></div><div class=toc><h3>Table of contents</h3><nav id=TableOfContents><ul><li><a href=#mathematical-matrix-order-row-major-column-vectors>Mathematical matrix order: row-major, column-vectors</a></li><li><a href=#programming-languages-are-x-order>&ldquo;Programming languages are X order&rdquo;</a></li><li><a href=#the-two-devils-of-graphics-programming>The two devils of graphics programming</a></li><li><a href=#endless-confusion>Endless confusion</a></li></ul></nav></div></main><div class=footer><a href=https://hexops.com/privacy>Privacy matters</a><p><a href=https://machengine.org/next/about#improve-this-site>Improve this site</a> | <a href=https://github.com/sponsors/slimsag>Sponsor on GitHub</a> | <a href=https://devlog.hexops.com/>Hexops' devlog</a></p></div></div></body></html>